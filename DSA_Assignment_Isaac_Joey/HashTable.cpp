#include "HashTable.h"
#include "AVLTree.h"
#include <string>
#include <cmath>
#include "Actor.h";
#include "Movie.h";
template class HashTable<Actor>;
template class HashTable<Movie>;
template <class T>
//HashTable constructor, intializes an array of MAX_SIZE with each AVLNode pointer in each index pointing to a nullptr 
// Also sets the size of the HashTable to 0 since there are no new elements 
// O(n) as it is dependant on the size of the hash table 

HashTable<T>::HashTable() {
	for (int i = 0; i < MAX_SIZE; i++) {
		items[i] = new AVLTree<T>();
	}
	size = 0;
};

// calcualte the hash given a year
// precondition: the year must be of type string 
// postcondition: the integer generated by the hashYear function is within the MAX_SIZE of the hash table since i used the modulo operator 
// convert to ascii value each of the numbers then do a polynomial rolling hash 

template <class T>
int HashTable<T>::hash(hashKey key) {
	int sum = 0;
	int base = 31;
	string strKey = to_string(key);
	int len = strKey.length();
	for (int i = 0; i < len; i++) {
		int digit = strKey[i] - '0';
		if (digit != NULL) {
			sum += digit * pow(base, len - i);
		}
	}
	if (sum != 0) {
		int hash = sum % 101;
		return hash;
	}
}

template <class T>
bool HashTable<T>::add(hashKey newKey, T item) {
	// hash the key first 
	int index = hash(newKey); // year of released or date of year for the actor 
	// call the insert method pass in the item;
	AVLTree<T>* avlTree = items[index];
	avlTree->insert(item);
	size++;
	return true;
}

template <class T>
bool HashTable<T>::isEmpty() {
	return size == 0;
}

template <class T>
int HashTable<T>::getLength() {
	return size;
}

template <class T>

void HashTable<T>::print() {
	for (int i = 0; i < getLength(); i++) {
		if (items[i] != nullptr) {
			AVLTree<T>* avlTree = items[i];
			avlTree->print();
		}
	}
}

template <class T>

AVLNode<T>* HashTable<T>::search(int id) {
	cout << "searching id: " << id << endl;
	for (int i = 0; i < MAX_SIZE; i++) {
		AVLTree<T>* avlTree = items[i];
		if (avlTree->getRoot() != nullptr) {
			AVLNode<T>* item = avlTree->searchAVLById(id);
			
			if (item != nullptr) {
				return item;
			}
		}
	}
	return nullptr;
}