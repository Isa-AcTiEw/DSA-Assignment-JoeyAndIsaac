#include "HashTable.h"
#include "AVLTree.h"
#include <cmath>
template <class T>
//HashTable constructor, intializes an array of MAX_SIZE with each AVLNode pointer in each index pointing to a nullptr 
// Also sets the size of the HashTable to 0 since there are no new elements 
// O(n) as it is dependant on the size of the hash table 

HashTable<T>::HashTable() {
	for (int i = 0; i < MAX_SIZE; i++) {
		items[i] = new AVLTree<T>();
	}
	size = 0;
};

// calcualte the hash given a year
// precondition: the year must be of type string 
// postcondition: the integer generated by the hashYear function is within the MAX_SIZE of the hash table since i used the modulo operator 
// convert to ascii value each of the numbers then do a polynomial rolling hash 

template <class T>
int HashTable<T>::hash(KeyType key) {
	int sum = 0;
	int base = 31;
	string strKey = to_string(key);
	int len = strKey.length;
	for (int i = 0; i < len; i++) {
		int digit = strKey[i] - '0';
		if (digit != null) {
			sum += digit * pow(base, len - i);
		}
	}
	if (sum != 0) {
		int hash = sum % 101;
	}
}

template <class T>
bool HashTable<T>::add(KeyType newKey, T item) {
	// hash the key first 
	int index = hash(newKey); // year of released or date of year for the actor 
	// call the insert method pass in the item;
	AVLTree<T>* avlTree = items[index];
	avlTree->insert(index);
	size++;
}

template <class T>
bool HashTable<T>::isEmpty() {
	return size == 0;
}

template <class T>
int HashTable<T>::getLength() {
	return size;
}

template <class T>

void HashTable<T>::print() {
	for (int i = 0; i < getLength(); i++) {
		if (items[i] != nullptr) {
			AVLTree<T>* avlTree = items[i];
			avlTree->print();
		}
		else {
			return size;
		}
	}
}